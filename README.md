# 关于vue3你需要知道

## vue3 RFC

vue2在经历几年的生命周期内，暴露出来的问题有：

1. 组件难以逻辑组合与复用
2. vue2缺少类型推导，即typescript支持
3. 打包尺寸较大，vue2中会将所有api的核心代码打包不论其在开发中是否有用到
4. definePropterty()实现的数组绑定无法实现数据对象新增属性值的变化，且vue中的数组方法也是自己polyfill实现的

vue3重新设计内部实现方式，并且设计一些新的api改善上述问题。主要有：

1. 重新设计响应式数据对象，从defineProperty()改为由浏览器原生支持的proxy实现。包括手动定义响应式数据()和包装对象（const a = ref(0)）两种方式。
   * 将数据变为响应式数据源，可以追踪数据的变化（包括数组和对象
   * 以变量的形式引用时（包括使用和修改）需要以a.value这种方式
   * 由包装对象使用计算属性（computed value）得到的数据也是一个只读的包装对象
   * 组件传递进来的属性值props也是响应式的数据

2. 重新设计了data组件选项，改为setup()
   * 代替vue2中data组件选项的作用，返回一数据对象，供组件模板使用
   * 只会在组件生成时执行一次，将组件中需要的数据定义成响应式数据

3. watch api可以基于观察状态的变化执行副作用函数，被观察的对象可以是包装对象/函数，或包含二者的数组。watch( )在组件的的setup或生命周期中调用，当创建时回调函数会立即执行一次，当观察的数据变化时，在renderer flush即DOM更新后回调函数会被执行，组件销毁时watch停止观察。
4. props属性，在3.0的setup()中接收参数props，其本身就是一个可观测下响应式对象
5. 类型推导，需要使用defineComponent函数定义组件

vue3的最终api还没有确定下来，想要详细查看的同学可以直接去文档查看。

## vue3对比react hooks

可以说vue3的最新设计很大程度上是借鉴了react hooks的思路。具体相似的地方至少有：

1. 定义数据的方式类似，react使用useState，vue3使用ref
2. setup设计借鉴了react hooks，抽取函数和复用逻辑的方式是类似的，都是可以将逻辑和数据抽取成为独立的函数进行复用。

而vue3也有其设计上的独特性：

1. react hooks在组件每次渲染的时候会重新执行一遍，而vue3的setup只会在组件初始化的时候执行一次
2. react hooks的useState创建组件状态值，处在一个独立的空间内，每次使用的时候从独立空间重新获取值。而vue3的包装对象则是使用proxy将数据对象变成可追踪的响应式数据，这个思路跟vue2是一样的。

vue3的设计在尤大看来至少有一下优势：

1. 整体上更符合 JavaScript 的直觉
2. 不受调用顺序的限制，可以有条件地被调用
3. 不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力
4. 不需要总是使用useCallback来缓存子组件的回调防止过度更新
5. 不需要关注useEffect/useMemo/useCallback的deps依赖数组是否正确

## vue3的新一代构建工具vite

vite是一种新型的项目构建工具，作用等同于webpack，但是原理与webpack不同。对比webpack有以下优势：
1. 快读冷启动
2. 瞬间热更新
3. 真正的按需编译

我总结了一下vite的技术原理：

1. 浏览器原生支持（ie除外）的ESM（script module）api，通过在script标签中添加type="module"就可以在代码中使用export import语法，通过浏览器端直接导入、导出模块使用。
2. ESM的原理是浏览器将import导入的模块转换成http请求加载对应的资源，需要什么模块就加载对应的模块。
3. vite将开启一个本地的koa服务，劫持ESM中由import导入模块时的http请求，所以vite与webpack不同，不会对代码中所需要的模块进行静态分析并抽取成bundle。
4. vite劫持后import导入的模块的http请求后，判断请求文件类型，对不同的模块文件使用不同的方法进行解析处理，如对vue文件，使用的就是vue的自带的模板解析/css解析/等功能，对css文件/ts文件等

## 给会使用vue3同学的一点建议

1. 可以对比性的使用react hooks试试看，目前react hooks也相对比较成熟了。
2. 建议以后项目都使用typescript开发。
